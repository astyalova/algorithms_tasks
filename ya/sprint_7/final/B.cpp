/*
https://contest.yandex.ru/contest/25597/run-report/134574284/

решение вдохновлено статьей https://habr.com/ru/articles/676858/

ПРИНЦИП РАБОТЫ:
Если первая строка длиннее второй, меняем их местами, чтобы работать с меньшим количеством памяти
Дальше заполняю вектор текущей строки количеством значений для преобразования пустой строки в s.
Для вычисления расстояния достаточно использовать две строки текующую и предыдущую
По сути в цикле мы смотрим сколько нужно операций для того, чтоб s[j] стало t[i]
добавление: значение из текущей строки на предыдущей позиции + 1,
удаление: значение из предыдущей строки на той же позиции + 1,
замену: значение из предыдущей строки на позиции j-1 + (0, если символы равны, иначе 1).
Выбираем минимальное значение из этих вариантов, так как нужно минимальное количество операций.
Последний элемент текущей строки и будет искомым расстоянием.

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ:
Алгоритм следует  формуле Левенштейна, где каждый шаг зависит от уже вычисленных значений.
Решение строится динамически, используя уже посчитанные значения.

ВРЕМЕННАЯ СЛОЖНОСТЬ:
Время работы O(mn), где n - длина первой строки, m — длина второй строки

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ:
Используется O(n) памяти, так как храним два вектора размера(n + 1)

*/

#include <string>
#include <iostream>
#include <vector>

int stringdDistance(std::string& s, std::string& t) {
    int n = s.size();
    int m = t.size();

    if(n > m) {
        return stringdDistance(t, s);
    }

    std::vector<int> current_str(n + 1, 0);

    for(int i = 0; i <= n; ++i) {
        current_str[i] = i;
    }

    for(int i = 1; i <= m; ++i) {
        std::vector<int> prev_str = current_str;
        current_str[0] = i;
        for(int j = 1; j <= n; ++j) {
            int add = prev_str[j]+ 1; 
            int del = current_str[j - 1] + 1;
            int change = prev_str[j - 1]; 

            if(s[j - 1] != t[i - 1]) {
                change += 1;
            }

            current_str[j] = std::min({add, del, change});
        }
    }
    return current_str[n];
}

int main() {
    std::string s, t;

    std::getline(std::cin, s);
    std::getline(std::cin, t);

    std::cout << stringdDistance(s, t);
}