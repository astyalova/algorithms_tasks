/*
https://contest.yandex.ru/contest/23815/run-report/130340290/
-- ПРИНЦИП РАБОТЫ --
Алгоритм реализуют бинарный поиск в массиве, где находится изначально середина, а потом
определяем как часть отсортирована левая или правая. Если элемент находится в отсортированной
части, то ищем там, иначе в другой.
то ищем там
-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Единственный алгоритм поиска в массиве за O(log n) - это бинарный поиск. Здесь его надо
немного модифицировать, так как массив не отсортирован. Алгоритм повторяется, сужая 
диапазон поиска в два раза на каждом шаге. Если элемент найден, возвращается его индекс.
Если поиск не увенчался успехом, функция вернёт -1.
-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Сложность бинарного поиска O(log n).
-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Алгоритм использует вектор для хранения чисел и переменные для вычислений. Пространственная сложность для вектора:
 O(n). Временные переменные (l, r, mid) занимают O(1) памяти. Итоговая: O(n).
*/

#include "solution.h"
#include <vector>
#include <cassert>

int broken_search(const std::vector<int>& vec, int k) {
    int l = 0;
    int r = vec.size()-1;

    while(l <= r) {
        int mid = (l + r)/2;

        if(vec[mid] == k) {
            return mid;
        }

        if(vec[l] <= vec[mid]) {
            if(vec[l] <= k && k < vec[mid]) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        } else {
            if(k > vec[mid] && k <= vec[r]) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
    }
    return -1;
}

void test() {
    std::vector<int> arr = {19, 21, 100, 101, 1, 4, 5, 7, 12};
    assert(6 == broken_search(arr, 5));
}